# 爬虫递归处理机制详解

## 概述

本文档详细说明物流追踪号爬虫的递归处理机制，包括时间比较逻辑、时区处理、防重复机制等核心功能。

## 目录

1. [核心设计理念](#核心设计理念)
2. [时间比较机制](#时间比较机制)
3. [时区处理](#时区处理)
4. [防重复处理机制](#防重复处理机制)
5. [递归退出逻辑](#递归退出逻辑)
6. [数据流向](#数据流向)
7. [错误处理和重试](#错误处理和重试)

---

## 核心设计理念

### 目标

- **不重复**：每个追踪号在单次调用中只处理一次
- **不遗漏**：所有待处理的追踪号都会被处理
- **自动递归**：前端自动调用，直到全部完成
- **时区一致**：确保时间比较的准确性

### 关键机制

1. **会话开始时间**：记录本次处理会话的开始时间
2. **时间比较**：只处理 `updated_at < NOW()` 的追踪号
3. **内存去重**：使用 `Set` 记录已处理的追踪号
4. **状态更新**：成功处理的追踪号更新 `updated_at`，失败的保持原样

---

## 时间比较机制

### 问题背景

最初设计使用 `sessionStartTime`（JavaScript `Date` 对象）与数据库的 `updated_at` 进行比较，但存在时区不一致的问题：

```typescript
// ❌ 问题代码
const sessionStartTime = new Date()  // JavaScript 本地时间
WHERE updated_at < $1  // 时区可能不一致
```

### 解决方案

**统一使用数据库的 `NOW()` 函数**，确保时区一致性：

```typescript
// ✅ 正确代码
WHERE updated_at IS NULL OR updated_at < NOW()
```

### 工作原理

1. **数据库连接时区设置**：
   ```typescript
   // lib/db.ts
   pool.on('connect', async (client) => {
     const timezone = process.env.DB_TIMEZONE || 'Asia/Shanghai'
     await client.query(`SET timezone = '${timezone}'`)
   })
   ```

2. **查询时使用 NOW()**：
   ```sql
   SELECT search_num, states
   FROM post_searchs
   WHERE (states NOT IN ('Final delivery', 'Returned to sender') OR states IS NULL)
     AND (updated_at IS NULL OR updated_at < NOW())
   ORDER BY updated_at ASC NULLS FIRST, id ASC
   LIMIT 20
   ```

3. **更新时使用 CURRENT_TIMESTAMP**：
   ```sql
   UPDATE post_searchs 
   SET states = $1, updated_at = CURRENT_TIMESTAMP
   WHERE search_num = $2
   ```

### 时间比较逻辑

```
查询条件：updated_at < NOW()

情况1：updated_at IS NULL
  → 满足条件，会被查询到（新导入的追踪号）

情况2：updated_at < NOW()
  → 满足条件，会被查询到（失败的追踪号，updated_at 未更新）

情况3：updated_at >= NOW()
  → 不满足条件，不会被查询到（刚刚成功处理的追踪号）
```

---

## 时区处理

### 时区设置

#### 1. 数据库连接时区

```typescript
// lib/db.ts
const dbConfig = {
  // ... 其他配置
  options: `-c timezone=${process.env.DB_TIMEZONE || 'Asia/Shanghai'}`,
}

pool.on('connect', async (client) => {
  const timezone = process.env.DB_TIMEZONE || 'Asia/Shanghai'
  await client.query(`SET timezone = '${timezone}'`)
  console.log(`数据库连接时区已设置为: ${timezone}`)
})
```

#### 2. 环境变量配置

在 `.env` 文件中设置（可选）：

```env
DB_TIMEZONE=Asia/Shanghai
```

如果不设置，默认使用 `Asia/Shanghai`（中国时间，GMT+8）。

### 时区一致性保证

#### 问题：为什么不能使用 JavaScript Date？

```typescript
// ❌ 问题代码
const sessionStartTime = new Date()  // 可能是 UTC 时间
// 转换为 ISO 字符串：2026-01-06T11:28:39.057Z（UTC）

// 数据库中的 updated_at 可能是：2026-01-06 19:28:39（中国时间）
// 比较时会出现时区不一致
```

#### 解决方案：使用数据库的 NOW()

```typescript
// ✅ 正确代码
// 所有时间比较都在 SQL 中完成，使用数据库的时区设置
WHERE updated_at < NOW()  // NOW() 使用数据库连接的时区（Asia/Shanghai）
```

### 时区转换示例

```
数据库时区：Asia/Shanghai (GMT+8)
当前时间：2026-01-06 19:28:39 CST

NOW() 返回：2026-01-06 19:28:39+08（中国时间）
updated_at：2026-01-06 19:28:30+08（中国时间）

比较：19:28:30 < 19:28:39 ✅ 正确
```

---

## 防重复处理机制

### 双重保护机制

#### 1. 数据库层保护

```sql
-- 只查询 updated_at < NOW() 的追踪号
-- 成功处理的追踪号会更新 updated_at = CURRENT_TIMESTAMP
-- 下次查询时，updated_at >= NOW()，不会被查询到
WHERE updated_at IS NULL OR updated_at < NOW()
```

#### 2. 内存层保护

```typescript
// 使用 Set 记录本次会话中已处理的追踪号
const processedSet = new Set<string>()

// 查询到的追踪号先过滤
const newItems = trackingNumbers.filter(
  (item) => !processedSet.has(item.search_num)
)

// 处理完后记录
newItems.forEach((item) => processedSet.add(item.search_num))
```

### 处理流程

```
1. 查询追踪号
   ↓
2. 过滤 processedSet 中的追踪号
   ↓
3. 处理追踪号
   ├─ 成功 → 更新 updated_at → 下次不会查询到（数据库层保护）
   └─ 失败 → 不更新 updated_at → 下次还会查询到，但会被 processedSet 过滤（内存层保护）
   ↓
4. 记录到 processedSet
   ↓
5. 继续下一批
```

---

## 递归退出逻辑

### 退出条件

#### 1. 没有更多待处理追踪号

```typescript
const trackingNumbers = await fetchPendingSearchNumbers(new Date())

if (trackingNumbers.length === 0) {
  console.log('✅ 没有更多待查询的追踪号')
  break  // 退出循环
}
```

#### 2. 所有追踪号都已在本会话处理过

```typescript
const newItems = trackingNumbers.filter(
  (item) => !processedSet.has(item.search_num)
)

if (newItems.length === 0) {
  // 检查是否还有新的追踪号（不在 processedSet 中的）
  const remainingCheck = await query(`
    SELECT COUNT(*) as count
    FROM post_searchs
    WHERE (states NOT IN ('Final delivery', 'Returned to sender') OR states IS NULL)
      AND (updated_at IS NULL OR updated_at < NOW())
      AND search_num != ALL($1::text[])
  `, [processedArray])
  
  if (remainingCount === 0) {
    break  // 退出循环
  }
}
```

#### 3. 接近超时限制

```typescript
if (!hasEnoughTime(startTime)) {
  // 提前返回，hasMore = true，前端会继续递归
  return {
    success: true,
    stats: { hasMore: true, ... }
  }
}
```

#### 4. 前端达到最大轮数

```typescript
// components/overseas-logistics.tsx
const MAX_ROUNDS = 20

if (roundCount >= MAX_ROUNDS) {
  // 停止递归
  break
}
```

### 前端递归逻辑

```typescript
// components/overseas-logistics.tsx
const handleUpdate = async () => {
  let roundCount = 0
  const MAX_ROUNDS = 20

  while (roundCount < MAX_ROUNDS) {
    roundCount++
    const result = await updateLogisticsStatus()

    if (result.stats?.hasMore) {
      // 还有待处理，1秒后继续下一轮
      await new Promise((resolve) => setTimeout(resolve, 1000))
      await handleUpdate(roundCount + 1)  // 递归调用
    } else {
      // 全部处理完成
      break
    }
  }
}
```

---

## 数据流向

### 完整流程

```
用户点击"更新"按钮
  ↓
前端：handleUpdate()
  ↓
后端：runCrawler()
  ├─ 获取数据库当前时间（用于日志）
  ├─ 查询待处理追踪号：WHERE updated_at < NOW()
  ├─ 过滤 processedSet 中的追踪号
  ├─ 处理追踪号
  │   ├─ 成功 → 更新 states 和 updated_at
  │   └─ 失败 → 不更新 updated_at
  ├─ 记录到 processedSet
  └─ 返回 hasMore 标志
  ↓
前端检查 hasMore
  ├─ true → 1秒后自动调用下一轮
  └─ false → 停止递归
```

### 单次调用流程

```
runCrawler() 开始
  ↓
记录 startTime（用于超时控制）
获取数据库当前时间（用于日志）
  ↓
while (hasEnoughTime(startTime)) {
  批次1：
    查询：WHERE updated_at < NOW()
    过滤：排除 processedSet 中的
    处理：20 个追踪号
    记录：添加到 processedSet
    更新：totalProcessed = stats.success + stats.failed
  
  批次2：
    查询：WHERE updated_at < NOW()
    （已处理的追踪号 updated_at 已更新，不会被查询到）
    过滤：排除 processedSet 中的
    处理：新的 20 个追踪号
    ...
  
  检查时间：
    如果接近超时 → 返回 hasMore = true
    如果查询为空 → break
}
  ↓
检查剩余追踪号：
  WHERE updated_at < NOW() AND search_num != ALL(processedSet)
  ↓
返回结果：
  hasMore = remainingCount > 0
```

---

## 错误处理和重试

### 单个追踪号重试

```typescript
async function processTrackingNumber(
  trackingNumber: string,
  maxRetries: number = 3
): Promise<{ success: boolean; retries: number }> {
  let retries = 0

  while (retries < maxRetries) {
    try {
      const result = await fetchTrackingInfo(trackingNumber)
      
      if (result && result.isNotRegistered) {
        // "Not registered" 算成功
        return { success: true, retries }
      }
      
      if (result && result.history && result.history.length > 0) {
        // 更新状态（会同时更新 updated_at）
        const stateUpdated = await updateSearchState(...)
        if (stateUpdated) {
          return { success: true, retries }
        }
      }
      
      // 失败，准备重试
      retries++
      if (retries < maxRetries) {
        const delay = Math.min(1000 * Math.pow(2, retries - 1), 2000)
        await new Promise((resolve) => setTimeout(resolve, delay))
      }
    } catch (error) {
      retries++
      // 重试逻辑...
    }
  }
  
  return { success: false, retries }
}
```

### 失败追踪号的处理

#### 成功处理的追踪号

```typescript
// 更新 states 和 updated_at
await updateSearchState(trackingNumber, newState)
// SQL: UPDATE post_searchs SET states = $1, updated_at = CURRENT_TIMESTAMP
// → updated_at 被更新为当前时间
// → 下次查询时，updated_at >= NOW()，不会被查询到
```

#### 失败处理的追踪号

```typescript
// 不更新 updated_at，保持原样
// → updated_at 仍然是旧值（NULL 或很久以前的值）
// → 下次查询时，updated_at < NOW()，仍然会被查询到
// → 可以继续重试
```

### 重试机制总结

1. **本次会话内重试**：`processTrackingNumber` 内部最多重试 3 次
2. **下次会话重试**：失败的追踪号 `updated_at` 不变，下次自动重试
3. **前端自动递归**：最多 20 轮，直到全部完成

---

## 关键代码片段

### 1. 查询待处理追踪号

```typescript
async function fetchPendingSearchNumbers(sessionStartTime: Date) {
  // 使用 NOW() 而不是 sessionStartTime，避免时区问题
  const sql = `
    SELECT search_num, states
    FROM post_searchs
    WHERE (states NOT IN ('Final delivery', 'Returned to sender') OR states IS NULL)
      AND (updated_at IS NULL OR updated_at < NOW())
    ORDER BY updated_at ASC NULLS FIRST, id ASC
    LIMIT ${BATCH_SIZE}
  `
  return await query(sql)
}
```

### 2. 更新状态（同时更新 updated_at）

```typescript
async function updateSearchState(searchNum: string, newState: string) {
  const sql = `
    UPDATE post_searchs 
    SET states = $1, updated_at = CURRENT_TIMESTAMP
    WHERE search_num = $2
  `
  const result = await execute(sql, [newState, searchNum])
  return result.affectedRows > 0
}
```

### 3. 防重复处理

```typescript
// 查询追踪号
const trackingNumbers = await fetchPendingSearchNumbers(new Date())

// 过滤已处理的
const newItems = trackingNumbers.filter(
  (item) => !processedSet.has(item.search_num)
)

// 处理
await processBatch(newItems, stats)

// 记录已处理的
newItems.forEach((item) => processedSet.add(item.search_num))
```

### 4. 检查剩余追踪号

```typescript
// 排除已处理的追踪号
const remainingCheck = await query(`
  SELECT COUNT(*) as count
  FROM post_searchs
  WHERE (states NOT IN ('Final delivery', 'Returned to sender') OR states IS NULL)
    AND (updated_at IS NULL OR updated_at < NOW())
    AND search_num != ALL($1::text[])
`, [Array.from(processedSet)])

const hasMore = remainingCheck[0]?.count > 0
```

---

## 常见问题

### Q1: 为什么处理了 0 个追踪号？

**可能原因**：
1. 所有追踪号都是最终状态（`Final delivery` 或 `Returned to sender`）
2. 所有追踪号的 `updated_at` 都 >= `NOW()`（刚刚处理过）
3. 数据库中没有待处理的追踪号

**解决方案**：
- 查看控制台日志，会显示详细的统计信息
- 检查数据库中的追踪号状态

### Q2: 时区不一致导致的问题

**问题**：使用 JavaScript `Date` 对象与数据库时间比较时，可能出现时区不一致。

**解决方案**：
- 统一使用数据库的 `NOW()` 函数
- 确保数据库连接时区设置正确（`Asia/Shanghai`）

### Q3: 重复处理问题

**问题**：同一个追踪号被处理多次。

**解决方案**：
- 使用 `processedSet` 记录已处理的追