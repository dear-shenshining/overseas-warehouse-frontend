# 导入数据逻辑测试与分析

## 一、当前导入流程

### 1.1 导入流程概览

```
导入Excel文件
    ↓
calculateInventoryData() - 计算库存数据、可售天数、标签
    ↓
importInventoryData() - 更新/插入 inventory 表
    ↓
检测任务完成（sale_day 从 >15 降到 <=15）
    ↓
如果任务完成 → 插入 task_history，删除 task
    ↓
syncInventoryToTask() - 同步 inventory 到 task 表
```

### 1.2 详细步骤分析

#### 步骤1：计算数据（`calculateInventoryData`）

**位置：** `app/actions/inventory.ts:121-220`

**功能：**
- 按SKU分组计算 `inventory_num`、`sales_num`
- 计算 `sale_day = (inventory_num * 7) / sales_num`
- 生成 `label` 数组（根据条件打标签）

**标签逻辑（当前）：**
- `sale_day > 15`（非爆款）或 `sale_day > 30`（爆款）→ 标签4
- **问题：** 需要改为 `sale_day > 20`（统一阈值）

#### 步骤2：导入到 inventory 表（`importInventoryData`）

**位置：** `lib/inventory-data.ts:117-264`

**逻辑：**
1. 检查 `inventory` 表中是否存在该SKU
2. 如果存在 → UPDATE（更新 `inventory_num`、`sales_num`、`sale_day`、`label`、`updated_at`）
3. 如果不存在 → INSERT（设置 `created_at`、`updated_at`）
4. **检查任务完成：**
   - 查询 `task` 表中是否有该SKU
   - 如果 `oldSaleDay > threshold && newSaleDay <= threshold` → 任务完成
   - 任务完成时：插入 `task_history`，删除 `task` 表中的记录

**时间字段处理：**
- UPDATE：只更新 `updated_at = CURRENT_TIMESTAMP`，`created_at` 保持不变 ✅
- INSERT：设置 `created_at = CURRENT_TIMESTAMP`，`updated_at = CURRENT_TIMESTAMP` ✅

#### 步骤3：同步到 task 表（`syncInventoryToTask`）

**位置：** `lib/inventory-data.ts:307-434`

**当前逻辑：**
```sql
-- 1. 先清空 task 表
DELETE FROM task

-- 2. 查询符合条件的 inventory 记录
SELECT * FROM inventory WHERE (label包含4) OR (label包含2但不包含1且不包含5)

-- 3. 插入到 task 表
INSERT INTO task (...) VALUES (...) 
ON CONFLICT (ware_sku) DO UPDATE SET ...
```

**问题分析：**

1. **问题1：先删除再插入导致 `created_at` 丢失**
   - 当前逻辑：先 `DELETE FROM task`，然后重新插入所有记录
   - 结果：所有任务的 `created_at` 都被重置为当前时间
   - **影响：** 倒计时计算错误，因为倒计时基于 `created_at`

2. **问题2：已有任务的更新逻辑不完善**
   - 当前逻辑：使用 `ON CONFLICT DO UPDATE`，但因为是先删除再插入，所以冲突不会发生
   - 应该改为：检查任务是否存在，如果存在则更新，如果不存在则插入

3. **问题3：任务状态字段未处理**
   - 当前逻辑：只更新 `promised_land`，没有处理 `task_status`
   - 如果任务在完成检查（`task_status=4`）或审核中（`task_status=5`），应该：
     - 保持 `created_at` 不变（倒计时继续计算）
     - 保持 `task_status`、`promised_land_snapshot` 等字段不变
     - 只更新数据字段（`inventory_num`、`sales_num`、`sale_day`、`label`、`charge`）

---

## 二、三表联动逻辑

### 2.1 inventory 表

**作用：** 存储所有库存数据（大盘数据）

**字段：**
- `ware_sku` (UNIQUE) - SKU货号
- `inventory_num` - 库存数量
- `sales_num` - 最近七天销量
- `sale_day` - 可售天数
- `label` (JSONB) - 标签列表
- `charge` - 负责人
- `created_at` - 创建时间（首次导入时设置）
- `updated_at` - 更新时间（每次导入时更新）

**更新逻辑：**
- 每次导入都会更新 `inventory_num`、`sales_num`、`sale_day`、`label`、`updated_at`
- `created_at` 保持不变（首次导入时设置）

### 2.2 task 表

**作用：** 存储需要处理的任务（从 inventory 表筛选）

**字段：**
- `ware_sku` (UNIQUE) - SKU货号
- `inventory_num` - 库存数量（从 inventory 同步）
- `sales_num` - 最近七天销量（从 inventory 同步）
- `sale_day` - 可售天数（从 inventory 同步）
- `label` (JSONB) - 标签列表（从 inventory 同步）
- `charge` - 负责人（从 inventory 同步）
- `promised_land` - 方案选择（用户操作）
- `task_status` - 任务状态（新增字段）
- `promised_land_snapshot` - 方案快照（新增字段）
- `count_down` - 倒计时（计算字段，基于 `created_at`）
- `image_urls` (JSONB) - 图片URL数组（用户上传）
- `created_at` - 创建时间（**关键：用于计算倒计时**）
- `updated_at` - 更新时间

**同步逻辑（当前问题）：**
- 先删除所有任务，然后重新插入
- **问题：** `created_at` 被重置，导致倒计时计算错误

**应该的逻辑：**
- 检查任务是否存在
- 如果不存在 → 插入新任务，`created_at = CURRENT_TIMESTAMP`
- 如果存在：
  - 如果 `task_status IN (4,5)`（完成检查/审核中）→ 保持 `created_at` 不变，只更新数据字段
  - 如果 `task_status IN (0,1,2,3)`（未选择方案/任务正在进行中）→ 可以更新 `created_at`（如果需要重置倒计时）

### 2.3 task_history 表

**作用：** 存储已完成的任务记录

**字段：**
- `ware_sku` - SKU货号（可以有重复）
- `completed_sale_day` - 完成时的可售天数
- `charge` - 完成时的负责人
- `promised_land` - 完成时选择的方案
- `completed_at` - 完成时间
- `inventory_num`、`sales_num`、`label` - 完成时的快照
- `review_status`、`reject_reason`、`task_status_snapshot` - 审核信息（新增字段）

**插入逻辑：**
- 在 `importInventoryData` 中检测到任务完成时插入
- 插入后从 `task` 表中删除该任务

---

## 三、时间字段联动问题

### 3.1 created_at 字段

**inventory 表：**
- 首次导入时设置，后续导入保持不变 ✅

**task 表：**
- **当前问题：** 每次同步时都被重置为当前时间 ❌
- **应该：** 
  - 新任务：`created_at = CURRENT_TIMESTAMP`
  - 已有任务：保持 `created_at` 不变（特别是完成检查/审核中的任务）

**task_history 表：**
- 插入时设置 `completed_at = CURRENT_TIMESTAMP` ✅

### 3.2 updated_at 字段

**inventory 表：**
- 每次导入时更新 ✅

**task 表：**
- 每次同步时更新 ✅
- 用户操作（选择方案、上传图片）时更新 ✅

**task_history 表：**
- 不需要 `updated_at`（历史记录不更新）✅

### 3.3 倒计时计算

**计算逻辑：** `lib/inventory-data.ts:272-299`

```sql
count_down = CASE 
  WHEN promised_land = 0 THEN 24 - EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - created_at)) / 3600
  ELSE 168 - EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - created_at)) / 3600
END
```

**问题：**
- 如果 `created_at` 被重置，倒计时会重新开始计算
- 对于完成检查/审核中的任务，应该保持原有的 `created_at`，倒计时继续计算

---

## 四、已有任务更新逻辑问题

### 4.1 当前逻辑

```typescript
// syncInventoryToTask() 中的逻辑
await connection.query('DELETE FROM task')  // 先删除所有任务

// 然后重新插入所有符合条件的记录
for (const record of results) {
  await connection.query(
    `INSERT INTO task (...) VALUES (...) 
     ON CONFLICT (ware_sku) DO UPDATE SET ...`
  )
}
```

**问题：**
1. 先删除再插入，`ON CONFLICT` 永远不会触发
2. 所有任务的 `created_at` 都被重置
3. 任务状态（`task_status`、`promised_land_snapshot` 等）丢失

### 4.2 应该的逻辑

```typescript
// 不应该先删除，而是检查每个任务是否存在
for (const record of results) {
  // 检查任务是否存在
  const existingTask = await connection.query(
    'SELECT * FROM task WHERE ware_sku = $1',
    [record.ware_sku]
  )
  
  if (existingTask.length > 0) {
    const task = existingTask[0]
    
    // 如果任务在完成检查或审核中，保持 created_at 和状态字段不变
    if (task.task_status IN (4, 5)) {
      await connection.query(
        `UPDATE task SET
          inventory_num = $1,
          sales_num = $2,
          sale_day = $3,
          charge = $4,
          label = $5,
          updated_at = CURRENT_TIMESTAMP
        WHERE ware_sku = $6`,
        [record.inventory_num, record.sales_num, record.sale_day, 
         record.charge, record.label, record.ware_sku]
      )
    } else {
      // 如果任务在未选择方案或任务正在进行中，可以更新所有字段
      await connection.query(
        `UPDATE task SET
          inventory_num = $1,
          sales_num = $2,
          sale_day = $3,
          charge = $4,
          label = $5,
          updated_at = CURRENT_TIMESTAMP
        WHERE ware_sku = $6`,
        [record.inventory_num, record.sales_num, record.sale_day, 
         record.charge, record.label, record.ware_sku]
      )
    }
  } else {
    // 新任务，插入
    await connection.query(
      `INSERT INTO task (...) VALUES (...)`,
      [...]
    )
  }
}

// 删除不再符合条件的任务（label不再包含2或4）
await connection.query(
  `DELETE FROM task 
   WHERE ware_sku NOT IN (
     SELECT ware_sku FROM inventory 
     WHERE (label::jsonb @> '[4]'::jsonb)
        OR ((label::jsonb @> '[2]'::jsonb)
            AND NOT (label::jsonb @> '[1]'::jsonb)
            AND NOT (label::jsonb @> '[5]'::jsonb))
   )`
)
```

---

## 五、修复方案

### 5.1 修复 syncInventoryToTask 函数

**需要修改：**
1. 不要先删除所有任务
2. 检查每个任务是否存在
3. 根据任务状态决定是否保持 `created_at` 不变
4. 删除不再符合条件的任务

### 5.2 修复标签逻辑

**需要修改：** `app/actions/inventory.ts:188-195`

**当前：**
```typescript
if (hasHotProduct && saleDay > 30) {
  labels.push(4)
} else if (!hasHotProduct && saleDay > 15) {
  labels.push(4)
}
```

**应该：**
```typescript
if (saleDay > 20) {  // 统一阈值20天
  labels.push(4)
}
```

### 5.3 处理任务重复出现逻辑

**需要修改：** `syncInventoryToTask` 函数

**场景：**
- 任务在完成检查（`task_status=4`）或审核中（`task_status=5`）
- 但 `inventory` 表中重新满足条件（label包含2或4）

**处理：**
- 如果任务在完成检查/审核中，流回任务正在进行中
- 保持 `created_at` 不变（倒计时继续计算）
- 重置状态字段：`task_status = promised_land_snapshot` 或 `promised_land`

---

## 六、测试用例

### 6.1 测试用例1：新任务创建

**场景：** 导入新SKU，label包含4

**预期：**
- `inventory` 表：INSERT，`created_at` = 当前时间
- `task` 表：INSERT，`created_at` = 当前时间，`task_status` = 0

### 6.2 测试用例2：已有任务更新

**场景：** 导入已有SKU，更新库存和销量

**预期：**
- `inventory` 表：UPDATE，`created_at` 不变，`updated_at` = 当前时间
- `task` 表：UPDATE，`created_at` 不变（如果任务在未选择方案/任务正在进行中）

### 6.3 测试用例3：任务完成

**场景：** SKU的可售天数从 >15 降到 <=15

**预期：**
- `task_history` 表：INSERT，`completed_at` = 当前时间
- `task` 表：DELETE（删除该任务）

### 6.4 测试用例4：完成检查中的任务重新出现

**场景：** 任务在完成检查中（`task_status=4`），但 `inventory` 表中重新满足条件

**预期：**
- `task` 表：UPDATE，保持 `created_at` 不变
- `task_status` 重置为 `promised_land_snapshot` 值
- 清除 `promised_land_snapshot`、`checked_at` 等字段

### 6.5 测试用例5：任务不再满足条件

**场景：** 任务在 `task` 表中，但 `inventory` 表中的 label 不再包含2或4

**预期：**
- `task` 表：DELETE（删除该任务）

---

## 七、修复代码位置

### 7.1 需要修改的文件

1. **`lib/inventory-data.ts`**
   - `syncInventoryToTask()` 函数（第307-434行）
   - 修改同步逻辑，不要先删除再插入

2. **`app/actions/inventory.ts`**
   - `calculateInventoryData()` 函数（第188-195行）
   - 修改标签4的判断条件为统一20天

### 7.2 新增功能

1. **任务重复处理逻辑**
   - 在 `syncInventoryToTask()` 中检测任务状态
   - 如果 `task_status IN (4,5)`，流回任务正在进行中

2. **时间字段保护**
   - 在更新任务时，根据 `task_status` 决定是否保持 `created_at` 不变

---

## 八、总结

### 8.1 主要问题

1. **`syncInventoryToTask()` 先删除再插入，导致 `created_at` 丢失**
2. **标签逻辑需要统一为20天**
3. **已有任务的更新逻辑不完善**
4. **任务状态字段未处理**

### 8.2 修复优先级

1. **高优先级：** 修复 `syncInventoryToTask()` 逻辑，保护 `created_at` 字段
2. **高优先级：** 修改标签逻辑为20天
3. **中优先级：** 处理任务重复出现逻辑
4. **低优先级：** 优化代码结构，提高可维护性

