# 滞销库存管理数据库索引优化说明

## 📋 概述

根据代码中的查询逻辑，为 `inventory`、`task`、`task_history` 三个表创建索引，提升查询性能。

## 🔍 查询分析

### inventory 表常用查询

1. **SKU 搜索**：`WHERE ware_sku = ?` 或 `WHERE ware_sku LIKE '%...%'`
2. **标签筛选**：`WHERE label::jsonb @> '[4]'::jsonb`（大量使用）
3. **排序**：`ORDER BY updated_at DESC, id DESC`
4. **统计查询**：基于 `label` 字段的 JSONB 查询

### task 表常用查询

1. **SKU 搜索**：`WHERE ware_sku = ?` 或 `WHERE ware_sku LIKE '%...%'`
2. **标签筛选**：`WHERE label::jsonb @> '[4]'::jsonb`
3. **状态筛选**：`WHERE promised_land = 0` 或 `WHERE promised_land IN (1, 2, 3)`
4. **负责人筛选**：`WHERE charge = ?`
5. **超时任务**：基于 `created_at` 计算 `count_down < 0`
6. **排序**：`ORDER BY updated_at DESC, id DESC`

### task_history 表常用查询

1. **SKU 搜索**：`WHERE ware_sku LIKE '%...%'`
2. **负责人筛选**：`WHERE charge = ?`
3. **方案筛选**：`WHERE promised_land = ?`
4. **日期筛选**：`WHERE completed_at >= ? AND completed_at <= ?`
5. **排序**：`ORDER BY completed_at DESC`
6. **标签统计**：`WHERE label::jsonb @> '[4]'::jsonb`

## 📊 索引方案

### 1. inventory 表索引

| 索引名称 | 索引类型 | 字段 | 用途 | 优先级 |
|---------|---------|------|------|--------|
| `idx_inventory_ware_sku` | B-tree | `ware_sku` | SKU 搜索 | ⭐⭐⭐ |
| `idx_inventory_label_gin` | GIN | `label` | JSONB 标签查询 | ⭐⭐⭐⭐⭐ |
| `idx_inventory_updated_at` | B-tree | `updated_at DESC` | 排序优化 | ⭐⭐⭐ |
| `idx_inventory_updated_at_id` | B-tree | `updated_at DESC, id DESC` | 复合排序 | ⭐⭐⭐⭐ |

### 2. task 表索引

| 索引名称 | 索引类型 | 字段 | 用途 | 优先级 |
|---------|---------|------|------|--------|
| `idx_task_ware_sku` | B-tree | `ware_sku` | SKU 搜索 | ⭐⭐⭐ |
| `idx_task_label_gin` | GIN | `label` | JSONB 标签查询 | ⭐⭐⭐⭐⭐ |
| `idx_task_promised_land` | B-tree | `promised_land` | 状态筛选 | ⭐⭐⭐⭐ |
| `idx_task_charge` | B-tree | `charge` | 负责人筛选 | ⭐⭐⭐⭐ |
| `idx_task_created_at` | B-tree | `created_at` | 倒计时计算 | ⭐⭐⭐⭐ |
| `idx_task_updated_at` | B-tree | `updated_at DESC` | 排序优化 | ⭐⭐⭐ |
| `idx_task_promised_land_charge` | B-tree | `promised_land, charge` | 组合查询 | ⭐⭐⭐ |
| `idx_task_updated_at_id` | B-tree | `updated_at DESC, id DESC` | 复合排序 | ⭐⭐⭐⭐ |

### 3. task_history 表索引

| 索引名称 | 索引类型 | 字段 | 用途 | 优先级 |
|---------|---------|------|------|--------|
| `idx_task_history_ware_sku` | B-tree | `ware_sku` | SKU 搜索 | ⭐⭐⭐ |
| `idx_task_history_charge` | B-tree | `charge` | 负责人筛选 | ⭐⭐⭐ |
| `idx_task_history_promised_land` | B-tree | `promised_land` | 方案筛选 | ⭐⭐⭐ |
| `idx_task_history_completed_at` | B-tree | `completed_at DESC` | 日期筛选和排序 | ⭐⭐⭐⭐⭐ |
| `idx_task_history_label_gin` | GIN | `label` | JSONB 标签查询 | ⭐⭐⭐⭐ |
| `idx_task_history_completed_at_promised_land` | B-tree | `completed_at DESC, promised_land` | 组合查询 | ⭐⭐⭐ |
| `idx_task_history_charge_completed_at` | B-tree | `charge, completed_at DESC` | 组合查询 | ⭐⭐⭐ |

## 🚀 执行步骤

### 1. 执行索引创建脚本

```bash
# 连接到数据库后执行
psql -U your_user -d seas_ware -f sql/postgresql/create_indexes_for_inventory_tables.sql
```

### 2. 验证索引创建

```sql
-- 查看所有索引
SELECT 
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE tablename IN ('inventory', 'task', 'task_history')
ORDER BY tablename, indexname;
```

### 3. 分析查询性能

```sql
-- 使用 EXPLAIN ANALYZE 查看查询计划
EXPLAIN ANALYZE
SELECT * FROM inventory 
WHERE label::jsonb @> '[4]'::jsonb
ORDER BY updated_at DESC, id DESC
LIMIT 50;
```

## ⚠️ 注意事项

### 1. GIN 索引创建时间

- GIN 索引创建时间较长，特别是数据量大的表
- 建议在低峰期执行
- 可以先创建其他索引，最后创建 GIN 索引

### 2. 索引维护

- 索引会占用存储空间
- 插入/更新数据时，索引也需要更新（会有一定性能开销）
- 定期执行 `VACUUM ANALYZE` 更新统计信息

### 3. 索引使用监控

```sql
-- 查看索引使用情况
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan as "使用次数",
    idx_tup_read as "读取行数",
    idx_tup_fetch as "获取行数"
FROM pg_stat_user_indexes
WHERE tablename IN ('inventory', 'task', 'task_history')
ORDER BY idx_scan DESC;
```

### 4. 删除未使用的索引

如果某个索引长期未被使用（`idx_scan = 0`），可以考虑删除：

```sql
-- 删除未使用的索引（谨慎操作）
DROP INDEX IF EXISTS idx_name;
```

## 📈 性能提升预期

### 预期提升

1. **JSONB 标签查询**：提升 **10-100 倍**（GIN 索引）
2. **排序查询**：提升 **5-20 倍**（排序索引）
3. **组合查询**：提升 **3-10 倍**（复合索引）
4. **统计查询**：提升 **5-50 倍**（根据数据量）

### 实际效果

执行索引后，建议：
1. 对比执行前后的查询时间
2. 使用 `EXPLAIN ANALYZE` 查看查询计划变化
3. 监控索引使用情况，优化未使用的索引

## 🔧 优化建议

### 1. 分批创建索引

如果数据量很大，可以分批创建：

```sql
-- 先创建最重要的索引
CREATE INDEX idx_inventory_label_gin ON inventory USING GIN(label);
CREATE INDEX idx_task_label_gin ON task USING GIN(label);
CREATE INDEX idx_task_history_completed_at ON task_history(completed_at DESC);

-- 等待一段时间后，再创建其他索引
```

### 2. 并发创建索引（PostgreSQL 12+）

```sql
-- 使用 CONCURRENTLY 选项，不阻塞表操作
CREATE INDEX CONCURRENTLY idx_inventory_label_gin 
ON inventory USING GIN(label);
```

### 3. 定期维护

```sql
-- 更新统计信息（建议每天执行）
VACUUM ANALYZE inventory;
VACUUM ANALYZE task;
VACUUM ANALYZE task_history;
```

## 📝 总结

最重要的索引（优先级最高）：

1. ✅ **GIN 索引**：`label` 字段（所有三个表）
2. ✅ **排序索引**：`updated_at DESC` 和 `completed_at DESC`
3. ✅ **筛选索引**：`promised_land`、`charge`、`created_at`

创建这些索引后，查询性能应该会有显著提升。

