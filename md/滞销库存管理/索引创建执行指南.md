# 索引创建执行指南

## ✅ 可以在新建查询中执行

**是的，完全可以在数据库管理工具的新建查询中执行这些 SQL 语句！**

支持的工具包括：
- pgAdmin
- DBeaver
- DataGrip
- VS Code 的数据库插件
- 任何支持 PostgreSQL 的查询工具

---

## 📝 执行步骤

### 方法一：使用快速修复脚本（推荐）

1. **打开数据库管理工具**（如 pgAdmin、DBeaver 等）
2. **连接到数据库** `seas_ware`
3. **新建查询窗口**
4. **复制粘贴以下 SQL**：

```sql
-- 1. GIN 索引（最重要！）
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_label_gin 
ON inventory USING GIN(label);

-- 2. 排序索引
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_updated_at_id 
ON inventory(updated_at DESC, id DESC);

-- 3. SKU 索引
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_ware_sku 
ON inventory(ware_sku);
```

5. **执行查询**（点击"执行"按钮或按 F5）

### 方法二：逐个执行（更安全）

如果担心一次性执行多个索引创建语句，可以逐个执行：

**第一步**：执行 GIN 索引（最重要）
```sql
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_label_gin 
ON inventory USING GIN(label);
```

**等待创建完成**（可能需要几分钟到几十分钟）

**第二步**：执行排序索引
```sql
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_updated_at_id 
ON inventory(updated_at DESC, id DESC);
```

**第三步**：执行 SKU 索引
```sql
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_ware_sku 
ON inventory(ware_sku);
```

---

## ⚠️ 重要注意事项

### 1. CONCURRENTLY 选项

**使用 CONCURRENTLY 的优势**：
- ✅ 不阻塞表的读写操作
- ✅ 可以在业务运行时执行
- ✅ 不会影响用户使用系统

**使用 CONCURRENTLY 的要求**：
- PostgreSQL 9.2 或更高版本
- 需要足够的磁盘空间（临时空间）
- 创建时间更长（但不会阻塞）

**如果 CONCURRENTLY 失败**：
- 可能是数据量太大或磁盘空间不足
- 可以尝试不使用 CONCURRENTLY（在维护窗口执行）

### 2. 执行时间

| 索引类型 | 数据量 | 预计时间 |
|---------|--------|---------|
| GIN 索引 | 1 万条 | 10-30 秒 |
| GIN 索引 | 10 万条 | 1-5 分钟 |
| GIN 索引 | 100 万条 | 10-30 分钟 |
| 排序索引 | 任意 | 几秒到几分钟 |
| SKU 索引 | 任意 | 几秒到几分钟 |

### 3. 监控执行进度

**在另一个查询窗口中执行**（查看创建进度）：

```sql
-- 查看正在创建的索引
SELECT 
    pid,
    now() - pg_stat_activity.query_start AS duration,
    query
FROM pg_stat_activity
WHERE query LIKE '%CREATE INDEX%'
  AND state = 'active';
```

---

## 🔍 验证索引创建成功

执行完成后，运行以下查询验证：

```sql
-- 查看已创建的索引
SELECT 
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE tablename = 'inventory'
  AND indexname LIKE 'idx_inventory%'
ORDER BY indexname;
```

**预期结果**：
```
schemaname | tablename  | indexname                      | indexdef
-----------|------------|--------------------------------|----------
public     | inventory  | idx_inventory_label_gin         | CREATE INDEX ...
public     | inventory  | idx_inventory_updated_at_id     | CREATE INDEX ...
public     | inventory  | idx_inventory_ware_sku          | CREATE INDEX ...
```

---

## 🚨 常见问题

### 问题 1：执行时间太长

**原因**：GIN 索引创建时间较长，特别是数据量大的时候

**解决方案**：
- 耐心等待（使用 CONCURRENTLY 不会阻塞表操作）
- 可以在另一个查询窗口查看进度
- 如果实在等不了，可以先创建排序索引和 SKU 索引（这两个很快）

### 问题 2：CONCURRENTLY 执行失败

**错误信息**：可能是磁盘空间不足或版本不支持

**解决方案**：
- 检查 PostgreSQL 版本（需要 9.2+）
- 检查磁盘空间
- 尝试不使用 CONCURRENTLY（在维护窗口执行）

### 问题 3：索引已存在

**错误信息**：`ERROR: relation "idx_inventory_label_gin" already exists`

**解决方案**：
- 使用 `IF NOT EXISTS` 选项（已包含在脚本中）
- 或者先删除旧索引：`DROP INDEX IF EXISTS idx_inventory_label_gin;`

---

## 📊 执行后立即测试

索引创建完成后，可以立即测试性能：

```sql
-- 测试统计查询性能（应该很快）
EXPLAIN ANALYZE
SELECT COUNT(*) FROM inventory WHERE label::jsonb @> '[4]'::jsonb;

-- 查看查询计划，确认使用了索引
-- 应该看到：Index Scan using idx_inventory_label_gin
```

---

## ✅ 总结

1. **可以在新建查询中执行**：完全支持
2. **推荐使用 CONCURRENTLY**：不阻塞业务
3. **逐个执行更安全**：可以先执行最重要的 GIN 索引
4. **执行后立即生效**：查询性能会大幅提升

**立即执行**：复制 `sql/postgresql/create_indexes_simple.sql` 中的 SQL 到查询工具执行即可！

