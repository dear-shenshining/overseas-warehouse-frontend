# 滞销库存管理性能优化紧急方案

## 🚨 当前性能问题

进入"滞销库存管理 - 大盘"页面时，会执行以下查询：

### 1. 主数据查询
```sql
SELECT * FROM inventory 
ORDER BY updated_at DESC, id DESC
```
**问题**：
- 查询所有数据（可能几万到几十万条）
- 没有索引时，需要全表扫描 + 全表排序
- 耗时：可能 3-10 秒

### 2. 统计查询（5个 COUNT 查询）
```sql
-- 1. 在售天数超15天
SELECT COUNT(*) FROM inventory WHERE label::jsonb @> '[4]'::jsonb

-- 2. 无销量
SELECT COUNT(*) FROM inventory WHERE label::jsonb @> '[2]'::jsonb

-- 3. 库存待冲平
SELECT COUNT(*) FROM inventory WHERE label::jsonb @> '[5]'::jsonb

-- 4. 有库存无销量
SELECT COUNT(*) FROM inventory 
WHERE (label::jsonb @> '[2]'::jsonb) 
  AND NOT (label::jsonb @> '[1]'::jsonb) 
  AND NOT (label::jsonb @> '[5]'::jsonb)

-- 5. 正常销售（最复杂）
SELECT COUNT(*) FROM inventory 
WHERE (label IS NULL OR label::text = '[]' 
  OR (NOT (label::jsonb @> '[1]'::jsonb) 
      AND NOT (label::jsonb @> '[2]'::jsonb) 
      AND NOT (label::jsonb @> '[4]'::jsonb) 
      AND NOT (label::jsonb @> '[5]'::jsonb)))
```

**问题**：
- 每个查询都需要扫描全表
- 每个查询都需要解析 JSONB
- 没有 GIN 索引时，每个查询可能耗时 2-5 秒
- 5 个查询总计：可能 10-25 秒

**总耗时：13-35 秒！**

---

## ⚡ 立即优化方案

### 方案 1：创建关键索引（最重要！）

**立即执行以下 SQL**：

```sql
-- 1. GIN 索引（最重要！JSONB 查询性能提升 10-100 倍）
CREATE INDEX CONCURRENTLY idx_inventory_label_gin 
ON inventory USING GIN(label);

-- 2. 排序索引（ORDER BY 性能提升 5-20 倍）
CREATE INDEX CONCURRENTLY idx_inventory_updated_at_id 
ON inventory(updated_at DESC, id DESC);

-- 3. 如果经常搜索 SKU，也创建这个索引
CREATE INDEX CONCURRENTLY idx_inventory_ware_sku 
ON inventory(ware_sku);
```

**执行时间**：
- `CONCURRENTLY` 选项：不阻塞表操作，可以在业务运行时执行
- GIN 索引创建时间：根据数据量，可能需要几分钟到几十分钟
- 其他索引：通常几秒到几分钟

**预期效果**：
- 统计查询：从 10-25 秒 → **0.1-0.5 秒**（提升 20-250 倍）
- 主数据查询：从 3-10 秒 → **0.2-1 秒**（提升 5-50 倍）
- **总耗时：从 13-35 秒 → 0.3-1.5 秒**

### 方案 2：优化查询（如果索引还不够）

#### 2.1 合并统计查询

**当前**：5 个独立的 COUNT 查询

**优化后**：使用一个查询计算所有统计

```sql
SELECT 
  COUNT(*) FILTER (WHERE label::jsonb @> '[4]'::jsonb) as over_15_days,
  COUNT(*) FILTER (WHERE label::jsonb @> '[2]'::jsonb) as no_sales,
  COUNT(*) FILTER (WHERE label::jsonb @> '[5]'::jsonb) as negative_inventory,
  COUNT(*) FILTER (WHERE (label::jsonb @> '[2]'::jsonb) 
                         AND NOT (label::jsonb @> '[1]'::jsonb) 
                         AND NOT (label::jsonb @> '[5]'::jsonb)) as has_inventory_no_sales,
  COUNT(*) FILTER (WHERE (label IS NULL OR label::text = '[]' 
                           OR (NOT (label::jsonb @> '[1]'::jsonb) 
                               AND NOT (label::jsonb @> '[2]'::jsonb) 
                               AND NOT (label::jsonb @> '[4]'::jsonb) 
                               AND NOT (label::jsonb @> '[5]'::jsonb)))) as normal_sales
FROM inventory;
```

**优势**：
- 只扫描一次表，而不是 5 次
- 性能提升：约 5 倍

#### 2.2 分页加载数据（前端优化）

**当前**：一次性加载所有数据

**优化后**：只加载第一页数据（50 条）

```typescript
// 修改查询，添加 LIMIT
SELECT * FROM inventory 
ORDER BY updated_at DESC, id DESC
LIMIT 50 OFFSET 0
```

**优势**：
- 初始加载时间：从 3-10 秒 → **0.1-0.3 秒**
- 用户体验：页面快速显示，用户可以立即看到数据

---

## 🎯 推荐执行顺序

### 第一步：立即创建索引（最重要）

```sql
-- 连接到数据库执行
\c seas_ware

-- 创建 GIN 索引（最重要，但创建时间较长）
CREATE INDEX CONCURRENTLY idx_inventory_label_gin 
ON inventory USING GIN(label);

-- 创建排序索引（快速）
CREATE INDEX CONCURRENTLY idx_inventory_updated_at_id 
ON inventory(updated_at DESC, id DESC);
```

**执行后立即生效**，查询性能会大幅提升。

### 第二步：验证索引效果

```sql
-- 查看索引是否创建成功
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename = 'inventory' 
  AND indexname LIKE 'idx_inventory%';

-- 测试查询性能（使用 EXPLAIN ANALYZE）
EXPLAIN ANALYZE
SELECT COUNT(*) FROM inventory WHERE label::jsonb @> '[4]'::jsonb;
```

### 第三步：如果还不够快，优化查询代码

修改 `lib/inventory-data.ts` 中的 `getInventoryStatistics` 函数，使用合并查询。

---

## 📊 性能对比

### 优化前

| 操作 | 耗时 | 说明 |
|------|------|------|
| 主数据查询 | 3-10 秒 | 全表扫描 + 排序 |
| 统计查询 1 | 2-5 秒 | label 包含 4 |
| 统计查询 2 | 2-5 秒 | label 包含 2 |
| 统计查询 3 | 2-5 秒 | label 包含 5 |
| 统计查询 4 | 2-5 秒 | label 包含 2 但不包含 1 和 5 |
| 统计查询 5 | 3-8 秒 | 正常销售（最复杂） |
| **总计** | **13-35 秒** | 用户体验极差 |

### 优化后（仅创建索引）

| 操作 | 耗时 | 说明 |
|------|------|------|
| 主数据查询 | 0.2-1 秒 | 使用排序索引 |
| 统计查询 1 | 0.05-0.1 秒 | 使用 GIN 索引 |
| 统计查询 2 | 0.05-0.1 秒 | 使用 GIN 索引 |
| 统计查询 3 | 0.05-0.1 秒 | 使用 GIN 索引 |
| 统计查询 4 | 0.1-0.2 秒 | 使用 GIN 索引 |
| 统计查询 5 | 0.1-0.3 秒 | 使用 GIN 索引 |
| **总计** | **0.3-1.5 秒** | 用户体验良好 |

**性能提升：20-100 倍！**

---

## 🔧 快速执行脚本

创建文件 `sql/postgresql/quick_fix_performance.sql`：

```sql
-- ============================================================
-- 滞销库存管理性能优化 - 快速修复
-- 立即执行，大幅提升查询性能
-- ============================================================

-- 1. GIN 索引（JSONB 查询，最重要！）
-- 创建时间：根据数据量，可能需要几分钟到几十分钟
-- 使用 CONCURRENTLY 不阻塞表操作
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_label_gin 
ON inventory USING GIN(label);

-- 2. 排序索引（ORDER BY 查询）
-- 创建时间：通常几秒到几分钟
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_updated_at_id 
ON inventory(updated_at DESC, id DESC);

-- 3. SKU 索引（如果经常搜索）
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_ware_sku 
ON inventory(ware_sku);

-- 查看创建进度（在另一个会话中执行）
SELECT 
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE tablename = 'inventory'
  AND indexname LIKE 'idx_inventory%'
ORDER BY indexname;
```

**执行方法**：
```bash
psql -U your_user -d seas_ware -f sql/postgresql/quick_fix_performance.sql
```

---

## ⚠️ 注意事项

### 1. CONCURRENTLY 选项

- ✅ **推荐使用**：不阻塞表的读写操作
- ⚠️ **缺点**：创建时间更长
- ⚠️ **要求**：PostgreSQL 9.2+，需要足够的磁盘空间

### 2. 如果 CONCURRENTLY 失败

如果使用 `CONCURRENTLY` 创建索引失败，可以尝试：

```sql
-- 不使用 CONCURRENTLY（会短暂锁表）
CREATE INDEX idx_inventory_label_gin 
ON inventory USING GIN(label);
```

**建议**：在业务低峰期执行。

### 3. 监控索引创建进度

```sql
-- 查看正在创建的索引
SELECT 
    pid,
    now() - pg_stat_activity.query_start AS duration,
    query
FROM pg_stat_activity
WHERE query LIKE '%CREATE INDEX%'
  AND state = 'active';
```

---

## 📈 预期效果

### 立即效果

执行索引创建后，查询性能会立即提升：
- ✅ 统计查询：从 10-25 秒 → **0.1-0.5 秒**
- ✅ 主数据查询：从 3-10 秒 → **0.2-1 秒**
- ✅ 页面加载：从 13-35 秒 → **0.3-1.5 秒**

### 长期效果

- ✅ 所有基于 `label` 的查询都会变快
- ✅ 所有排序查询都会变快
- ✅ 用户体验显著提升

---

## 🎯 总结

**最紧急的操作**：立即创建 GIN 索引

```sql
CREATE INDEX CONCURRENTLY idx_inventory_label_gin 
ON inventory USING GIN(label);
```

这一个索引就能解决 80% 的性能问题！

