# 滞销库存管理 - Excel导入功能需求与实现方案

## 📋 一、功能概述

实现滞销库存管理页面的Excel文件导入功能，将Excel文件中的库存和销售数据导入到数据库的`inventory`表中。

---

## 🎯 二、详细需求分析

### 2.1 输入数据源

**Excel文件格式：**
- 文件路径示例：`C:\Users\Administrator\Desktop\海外仓前端页面\库存商品实时销售报表2025_12_29_16_13_52.xlsx`
- 文件类型：`.xlsx`（Excel 2007+格式）

**Excel文件中的关键列：**
1. **马帮SKU** - 商品的唯一标识符（SKU编码）
2. **仓库** - 仓库名称（所有仓库数据都会被汇总）
3. **库存数量** - 当前库存数量
4. **待发货量** - 待发货的数量
5. **在途量** - 在途中的数量
6. **最近7天销量** - 最近7天的销售数量

### 2.2 目标数据库表结构

**表名：** `inventory` 和 `task`

**inventory 表字段说明：**
| 字段名 | 类型 | 说明 | 数据来源 |
|--------|------|------|----------|
| `id` | INT (自增主键) | 记录唯一标识 | 数据库自动生成 |
| `ware_sku` | VARCHAR | 马帮SKU（唯一，不重复不遗漏） | Excel的"马帮SKU"列 |
| `inventory_num` | INT | 库存数量（计算值） | 通过公式计算得出 |
| `sales_num` | INT | 最近7天销量 | Excel的"最近7天销量"列（所有仓库汇总） |
| `sale_day` | INT | 可售天数 | 根据库存数量和销量计算 |
| `charge` | VARCHAR | 负责人 | 从 per_charge 表匹配 |
| `label` | JSON | 标签列表 | 根据条件自动生成 |
| `created_at` | DATETIME | 创建时间 | 系统当前时间 |
| `updated_at` | DATETIME | 更新时间 | 系统当前时间 |

**task 表：**
- 结构与 `inventory` 表一致
- 自动同步符合条件的记录（label 包含 4 或 label 包含 2 但不包含 1 且不包含 5）

**注意：** `ware_sku`字段需要确保不重复、不遗漏，即：
- 每个唯一的"马帮SKU"在数据库中只对应一条记录
- Excel中的所有"马帮SKU"都需要被处理

### 2.3 数据计算规则

#### 2.3.1 `inventory_num`（库存数量）计算规则

**筛选条件：**
- 当前行的"马帮SKU" = 目标SKU
- 所有仓库的数据都会被汇总

**计算公式：**
```
inventory_num = SUM(所有仓库的库存数量) - SUM(所有仓库的待发货量) + SUM(所有仓库的在途量)
```

**计算逻辑：**
1. 在Excel中筛选出所有相同SKU的行（所有仓库）
2. 对这些行的数据进行累加：
   - 累加所有"库存数量"列的值
   - 累加所有"待发货量"列的值
   - 累加所有"在途量"列的值
3. 应用公式：`累加的库存数量 - 累加的待发货量 + 累加的在途量`
4. 结果作为该SKU的`inventory_num`值

**示例：**
假设SKU "ABC123" 在Excel中有以下数据：
- 行1：浙江义乌仓，库存数量=100，待发货量=20，在途量=10
- 行2：海外仓备货仓，库存数量=50，待发货量=5，在途量=8
- 行3：其他仓库，库存数量=30，待发货量=3，在途量=2

计算过程：
- SUM(库存数量) = 100 + 50 + 30 = 180
- SUM(待发货量) = 20 + 5 + 3 = 28
- SUM(在途量) = 10 + 8 + 2 = 20
- inventory_num = 180 - 28 + 20 = 172

#### 2.3.2 `sales_num`（最近7天销量）计算规则

**筛选条件：**
- 当前行的"马帮SKU" = 目标SKU
- 所有仓库的数据都会被汇总

**计算逻辑：**
1. 在Excel中筛选出所有相同SKU的行（所有仓库）
2. 累加这些行的"最近7天销量"列的值
3. 结果作为该SKU的`sales_num`值

**示例：**
假设SKU "ABC123" 在Excel中有以下数据：
- 行1：浙江义乌仓，最近7天销量=15
- 行2：海外仓备货仓，最近7天销量=8
- 行3：其他仓库，最近7天销量=5

计算过程：
- sales_num = 15 + 8 + 5 = 28

### 2.4 数据处理流程

1. **文件上传**
   - 用户点击"导入数据"按钮
   - 弹出文件选择对话框
   - 用户选择Excel文件（`.xlsx`格式）
   - 验证文件格式和大小

2. **Excel文件解析**
   - 使用`xlsx`库读取Excel文件
   - 解析第一行作为表头，识别列名
   - 读取所有数据行
   - 验证必要列是否存在（马帮SKU、仓库、库存数量、待发货量、在途量、最近7天销量）

3. **数据分组和计算**
   - 按"马帮SKU"分组
   - 对每个SKU：
     - 筛选出指定仓库的数据行
     - 计算`inventory_num`（库存数量 - 待发货量 + 在途量）
     - 计算`sales_num`（累加最近7天销量）

4. **数据库操作**
   - 对每个SKU：
     - 检查数据库中是否已存在该`ware_sku`
     - 如果存在：执行`UPDATE`操作，更新`inventory_num`和`sales_num`
     - 如果不存在：执行`INSERT`操作，插入新记录
   - 使用事务确保数据一致性

5. **结果反馈**
   - 显示导入结果统计：
     - 成功导入的记录数
     - 更新的记录数
     - 新增的记录数
     - 失败的记录数（如果有）
   - 显示错误信息（如果有）

---

## 🏗️ 三、技术实现方案

### 3.1 技术栈

- **前端：** React + Next.js + TypeScript
- **文件处理：** `xlsx`库（已安装）
- **数据库：** MySQL（使用`mysql2`库）
- **数据交互：** Next.js Server Actions

### 3.2 文件结构

```
lib/
  ├── inventory-data.ts      # 库存数据服务（数据库操作）
app/
  └── actions/
      └── inventory.ts       # Server Actions（导入功能）
components/
  └── slow-moving-inventory.tsx  # 滞销库存管理组件（更新导入功能）
```

### 3.3 核心功能模块

#### 3.3.1 Excel文件解析模块

**位置：** `app/actions/inventory.ts`

**功能：**
- 接收上传的Excel文件（FormData格式）
- 使用`xlsx`库解析Excel文件
- 识别列名并映射到数据字段
- 返回解析后的数据数组

**关键代码逻辑：**
```typescript
import * as XLSX from 'xlsx'

// 解析Excel文件
function parseExcelFile(fileBuffer: Buffer) {
  const workbook = XLSX.read(fileBuffer, { type: 'buffer' })
  const sheetName = workbook.SheetNames[0] // 读取第一个工作表
  const worksheet = workbook.Sheets[sheetName]
  const data = XLSX.utils.sheet_to_json(worksheet) // 转换为JSON数组
  
  // 验证必要列是否存在
  // 返回数据数组
}
```

#### 3.3.2 数据计算模块

**位置：** `app/actions/inventory.ts`

**功能：**
- 按"马帮SKU"分组数据
- 筛选指定仓库的数据
- 计算`inventory_num`和`sales_num`

**关键代码逻辑：**
```typescript
// 按SKU分组并计算（所有仓库数据汇总）
function calculateInventoryData(excelData: any[]) {
  const skuMap = new Map()
  
  // 按SKU分组
  excelData.forEach(row => {
    const sku = row['马帮SKU']
    if (!sku) return
    
    if (!skuMap.has(sku)) {
      skuMap.set(sku, {
        sku,
        inventoryRows: [],
        salesRows: []
      })
    }
    
    // 处理所有仓库的数据
    skuMap.get(sku).inventoryRows.push(row)
    skuMap.get(sku).salesRows.push(row)
  })
  
  // 计算每个SKU的值
  const result = []
  skuMap.forEach((value, sku) => {
    const inventoryNum = calculateInventoryNum(value.inventoryRows)
    const salesNum = calculateSalesNum(value.salesRows)
    const saleDay = salesNum > 0 ? Math.round((inventoryNum * 7) / salesNum) : null
    const labels = generateLabels(inventoryNum, salesNum, saleDay)
    
    result.push({
      ware_sku: sku,
      inventory_num: inventoryNum,
      sales_num: salesNum,
      sale_day: saleDay,
      label: labels
    })
  })
  
  return result
}

// 导入完成后自动同步到 task 表
// 同步条件：label 包含 4 或 label 包含 2 但不包含 1 且不包含 5
```

#### 3.3.3 数据库操作模块

**位置：** `lib/inventory-data.ts`

**功能：**
- 批量插入或更新库存数据
- 使用事务确保数据一致性
- 处理重复SKU的情况（UPDATE或INSERT）

**关键代码逻辑：**
```typescript
import { query, execute, getConnection } from '@/lib/db'

// 批量导入库存数据
export async function importInventoryData(data: InventoryRecord[]) {
  const connection = await getConnection()
  await connection.beginTransaction()
  
  try {
    for (const record of data) {
      // 检查是否存在
      const existing = await query(
        'SELECT id FROM inventory WHERE ware_sku = ?',
        [record.ware_sku]
      )
      
      if (existing.length > 0) {
        // 更新
        await execute(
          'UPDATE inventory SET inventory_num = ?, sales_num = ?, updated_at = NOW() WHERE ware_sku = ?',
          [record.inventory_num, record.sales_num, record.ware_sku]
        )
      } else {
        // 插入
        await execute(
          'INSERT INTO inventory (ware_sku, inventory_num, sales_num, created_at, updated_at) VALUES (?, ?, ?, NOW(), NOW())',
          [record.ware_sku, record.inventory_num, record.sales_num]
        )
      }
    }
    
    await connection.commit()
    return { success: true }
  } catch (error) {
    await connection.rollback()
    throw error
  } finally {
    connection.release()
  }
}
```

#### 3.3.4 Server Action

**位置：** `app/actions/inventory.ts`

**功能：**
- 接收前端上传的文件
- 调用解析和计算模块
- 调用数据库操作模块
- 返回导入结果

**关键代码逻辑：**
```typescript
'use server'

export async function importInventoryFile(formData: FormData) {
  try {
    const file = formData.get('file') as File
    if (!file) {
      return { success: false, error: '未选择文件' }
    }
    
    // 读取文件
    const arrayBuffer = await file.arrayBuffer()
    const buffer = Buffer.from(arrayBuffer)
    
    // 解析Excel
    const excelData = parseExcelFile(buffer)
    
    // 计算数据
    const inventoryData = calculateInventoryData(excelData)
    
    // 导入数据库
    await importInventoryData(inventoryData)
    
    return {
      success: true,
      message: `成功导入 ${inventoryData.length} 条记录`
    }
  } catch (error: any) {
    return {
      success: false,
      error: error.message || '导入失败'
    }
  }
}
```

#### 3.3.5 前端组件更新

**位置：** `components/slow-moving-inventory.tsx`

**功能：**
- 添加文件上传功能
- 调用Server Action
- 显示导入进度和结果

**关键代码逻辑：**
```typescript
const handleImport = async (e: React.ChangeEvent<HTMLInputElement>) => {
  const file = e.target.files?.[0]
  if (!file) return
  
  // 验证文件类型
  if (!file.name.endsWith('.xlsx')) {
    alert('请选择Excel文件（.xlsx格式）')
    return
  }
  
  // 创建FormData
  const formData = new FormData()
  formData.append('file', file)
  
  // 调用Server Action
  const result = await importInventoryFile(formData)
  
  if (result.success) {
    alert(result.message)
    // 刷新数据
  } else {
    alert(`导入失败：${result.error}`)
  }
}
```

---

## 📊 四、数据库表结构设计

### 4.1 创建inventory表的SQL语句

```sql
CREATE TABLE IF NOT EXISTS `inventory` (
  `id` INT AUTO_INCREMENT PRIMARY KEY COMMENT '主键ID',
  `ware_sku` VARCHAR(255) NOT NULL UNIQUE COMMENT '马帮SKU（唯一标识）',
  `inventory_num` DECIMAL(10, 2) DEFAULT 0 COMMENT '库存数量（计算值）',
  `sales_num` DECIMAL(10, 2) DEFAULT 0 COMMENT '最近7天销量',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  INDEX `idx_ware_sku` (`ware_sku`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='库存表';
```

### 4.2 字段说明

- **id**: 自增主键，唯一标识每条记录
- **ware_sku**: 马帮SKU，唯一索引，确保不重复
- **inventory_num**: 库存数量，使用DECIMAL类型支持小数
- **sales_num**: 最近7天销量，使用DECIMAL类型支持小数
- **created_at**: 创建时间，自动记录
- **updated_at**: 更新时间，自动更新

---

## ⚠️ 五、注意事项和边界情况

### 5.1 数据验证

1. **Excel文件格式验证**
   - 必须是`.xlsx`格式
   - 文件大小限制（建议不超过10MB）
   - 必须包含必要的列：马帮SKU、仓库、库存数量、待发货量、在途量、最近7天销量

2. **数据完整性验证**
   - "马帮SKU"不能为空
   - 数值字段（库存数量、待发货量、在途量、最近7天销量）必须是有效数字
   - 如果某个SKU在指定仓库中没有数据，`inventory_num`和`sales_num`应该为0

3. **数据一致性**
   - 使用数据库事务确保批量操作的一致性
   - 如果导入过程中出现错误，回滚所有操作

### 5.2 性能优化

1. **批量处理**
   - 对于大量数据，考虑分批处理（每批1000条）
   - 使用数据库批量插入/更新语句提高性能

2. **错误处理**
   - 记录每个SKU的处理结果
   - 如果某个SKU处理失败，不影响其他SKU的处理
   - 返回详细的错误信息

### 5.3 用户体验

1. **进度提示**
   - 显示文件上传进度
   - 显示数据处理进度
   - 显示导入结果统计

2. **错误提示**
   - 清晰的错误信息
   - 建议的解决方案

---

## 🔄 六、数据流程图

```
用户选择Excel文件
    ↓
前端验证文件格式
    ↓
上传文件到Server Action
    ↓
解析Excel文件（xlsx库）
    ↓
验证列名和数据完整性
    ↓
按"马帮SKU"分组数据
    ↓
筛选指定仓库的数据
    ↓
计算inventory_num和sales_num
    ↓
开始数据库事务
    ↓
对每个SKU：
  - 检查是否存在
  - 存在则UPDATE，不存在则INSERT
    ↓
提交事务
    ↓
返回导入结果
    ↓
前端显示结果
```

---

## 📝 七、待确认事项

1. **Excel文件列名确认**
   - 确认Excel文件中的列名是否完全匹配（"马帮SKU"、"仓库"、"库存数量"、"待发货量"、"在途量"、"最近7天销量"）
   - 是否需要支持列名的变体（如"SKU"、"马帮SKU编码"等）

2. **仓库名称确认**
   - 确认仓库名称是否完全匹配（"浙江义乌仓"、"海外仓备货仓"、"青岛仓库"、"日根野日本海外仓"）
   - 是否需要支持大小写不敏感匹配

3. **数值精度**
   - `inventory_num`和`sales_num`是否需要支持小数
   - 如果需要，保留几位小数

4. **导入策略**
   - 是否每次导入都完全替换现有数据
   - 还是只更新已存在的SKU，新增不存在的SKU

5. **错误处理策略**
   - 如果某个SKU的数据计算失败，是否跳过该SKU继续处理
   - 还是整个导入过程失败

---

## ✅ 八、实现检查清单

- [ ] 创建`lib/inventory-data.ts`文件（数据库操作）
- [ ] 创建`app/actions/inventory.ts`文件（Server Actions）
- [ ] 更新`components/slow-moving-inventory.tsx`（添加文件上传功能）
- [ ] 创建数据库表`inventory`（如果不存在）
- [ ] 实现Excel文件解析功能
- [ ] 实现数据计算功能（inventory_num和sales_num）
- [ ] 实现数据库批量导入功能（INSERT/UPDATE）
- [ ] 添加错误处理和用户提示
- [ ] 测试导入功能
- [ ] 优化性能和用户体验

---

## 📌 九、总结

本方案详细描述了滞销库存管理Excel导入功能的完整实现方案，包括：

1. **需求分析**：明确了数据来源、目标表结构、计算规则
2. **技术方案**：使用Next.js Server Actions + xlsx库 + MySQL数据库
3. **实现细节**：提供了关键代码逻辑和文件结构
4. **注意事项**：涵盖了数据验证、性能优化、用户体验等方面

在开始编码之前，建议先确认"待确认事项"中的内容，确保实现方案完全符合实际需求。

